#! /usr/local/bin/perl -w# Paul Sciortino# paul@hieroglyphs.net# February 8, 2002use strict;use CGI qw(:standard);my $debug1 = 0;my $debug2 = 0;my $debug3 = 0;my $debug4 = 0;my $source_file = "beinlich.txt";my $search_page = "/egypt/beinlich/beinform.html";my $search = param("s1");my @lines;my $line;my @found;my @rows;my $output;print "Content-type: text/html\n\n";#______________________________________________________________________________# read in the data file@lines = read_lines($source_file, 1, "all");if ($debug1) { print @lines; }#______________________________________________________________________________# search for the target string in each line of the data file# and save the found lines# # I assume that every data line begins with @ and the# transliteration field ends with &foreach $line(@lines){	if ($line =~ /^@ .*$search.* &/)	{		push(@found, $line);	}}if ($debug2) { print @found; }#______________________________________________________________________________# loop through the found lines and prepare the html outputforeach $line(@found){	$line = recode($line);	$line =~ s/^@ *(.*) *& +(.*) *!! *(.*)/<tr><td class="t">$1<\/td><td class="m">$2<\/td><td class="s">$3<\/td><\/tr>/;	push(@rows, $line);}if ($debug3) { print @rows; }#______________________________________________________________________________# assemble XHTML output$output .= qq{<?xml version="1.0" encoding="UTF-8" ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Beinlich Search Results</title><style type="text/css"><!--body {	margin: 10px;	padding: 0;	color: #000000;	background: #ffffff;	font: 12px/1.2 sans-serif;	}h1 {	font: 20px sans-serif;	font-weight: bold;	padding: 3px;	}	td, th, a {	font: 12px/1.2 sans-serif;	text-align: left;	vertical-align: top;	}p.validation {	color: #cccccc;	font-size: 9px;	padding: 5px 0 0 0;	}	/* transliteration */td.t {	font-weight: bold;	}/* meaning */td .m {	}/* source */td.s {	font-style: italic;	}-->	</style></head><body><h1>Beinlich Search Results</h1><table><tr><th>Word</th><th>Translation</th><th>Reference</th></tr>};foreach $line(@rows){	$output .= "$line";}$output .= qq{</table><hr /><p><a href="$search_page">Search again</a></p><!--<p class="validation"><a href="http://validator.w3.org/check/referer">XHTML 1.0</a> | <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS 2.0</a></p>--></body></html>};if ($debug4) { print $output; }#______________________________________________________________________________# send it to the browserprint $output;#______________________________________________________________________________sub recode{	my $line = $_[0];	my $key;	my %replacement_table = qw( 								<	&#60;								>	&#62;								%\/a	&#225;								%\/E	&#201;								%\/e	&#233;								%\/y	&#253;								%\e	&#232;								%>C	&#268;								\^A	&#196;								\^a	&#228;								\^O	&#214;								\^o	&#246;								\^U	&#220;								\^u	&#252;								\^s	&#223;							);		foreach $key(keys(%replacement_table))	{		$line =~ s/$key/$replacement_table{$key}/g;	}	return $line;}sub read_lines{	# If last argument is "all", rest of file starting at $start_line is read.	# First argument is full path.	#	# call: @lines = read_lines($target_file, $start_line, $lines_to_read)	#		#	my @lines;	#	#	@lines = read_lines("test.txt", 1, "all");	#	print @lines;	#		#	@lines = read_lines("test.txt", 2, 2);	#	print @lines;	#		#	@lines = read_lines("test.txt", 1, 4);	#	print @lines;		my $target_file = $_[0];	my $start_line = $_[1];	my $lines_to_read = $_[2];	my $i;	my $trash;	my @lines;	if (-e $target_file)     # i.e., if the file exists	{		open(INPUT, "$target_file") || die "  - read_lines() Can't open target_file for read ($target_file): $!";		for ($i = 1; $i < $start_line; $i++) { $trash = <INPUT>;}		if ($lines_to_read eq "all")		{			@lines = <INPUT>;		}		else		{			for ($i = 1; $i <= $lines_to_read; $i++) { $lines[$i-1] = <INPUT>;}		}		close(INPUT) || die "  - read_lines() Can't close target_file from read ($target_file): $!";	}	else	{		@lines = ""	}	return(@lines);}#______________________________________________________________________________